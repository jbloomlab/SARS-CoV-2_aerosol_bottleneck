---
title: "5. Calculate Transmission Bottleneck"
author:
    - "Will Hannon"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
  highlight: tango
  number_sections: no
  theme: default
  toc: yes
  toc_depth: 3
  toc_float:
    collapsed: no
    smooth_scroll: yes
---

The goal of this notebook is to calculate the transmission bottleneck for the different aerosol sizes. Each cage has 4 animal, 2 contacts and 2 donors. I'll calculate the bottleneck assuming each possible donor/contact pair. I'll also calculate the bottleneck from the inoculate to each donor animal. Depending on the results, I'll try more stringent filters on the variants to see if this impacts the overall bottleneck size. 

```{r Setup, include=FALSE}
require("knitr")
knitr::opts_chunk$set(echo = FALSE)
```

```{r Required Packages, message=FALSE, warning=FALSE}

## ==== Install Required Packages ==== ##

## List of all packages needed
packages = c("tidyverse", "rmutil", "data.table")
invisible(lapply(c(packages), library, character.only = TRUE))

```

```{r Inputs, echo=T}

## ==== File paths input data ==== ##

if (exists("snakemake")) {
  
  # Sample metadata
  sample.metadata.data = snakemake@input[[1]]
  
  # Variant calls from pysam, varscan, ivar, and lofreq
  variant.calls.data = snakemake@input[[2]]
  
  # Merged variant calls from the previous notebook 
  merged.variant.calls.data = snakemake@input[[3]]
  
  # Primer BED
  primer.bed.data = snakemake@input[[4]]

} else {

  # Sample metadata
  sample.metadata.data = "../../config/samples.csv"
  
  # Variant calls from pysam, varscan, ivar, and lofreq
  variant.calls.data = "../../results/variants/variants.csv"
  
  # Merged variant calls from the previous notebook 
  merged.variant.calls.data = "../../results/variants/merged_variants.csv"
  
  # Primer BED
  primer.bed.data = "../../results/reference/primers/primers.bed"
  
}

```

```{r Output Directory, echo=T}

figures.dir = "../../results/figures/"

```

```{r Load Data, echo=TRUE, warning=FALSE}

merged.df = read_csv(merged.variant.calls.data, show_col_types = FALSE) %>% 
  # Fix the naming scheme of experiment 19 
  mutate(Condition = case_when(
    Experiment == 19 & Pair == 'aerosol' ~ 'aerosol transmission',
    Experiment == 19 & Pair == 'direct' ~ 'direct transmission',
    TRUE ~ Condition
  )) %>% 
  # Standardize the pair names to contact and donor
  mutate(Pair = case_when(
    Pair == 'aerosol' ~ 'contact',
    Pair == 'direct' ~ 'contact',
    Pair == 'recipient' ~ 'contact',
    TRUE ~ Pair
  ))

# Un-merged variant calls
variant.df = read_csv(variant.calls.data, show_col_types = FALSE)

# Primer positions
primer.df = fread(primer.bed.data) %>% 
  select(contig = V1,
         start = V2, 
         end = V3, 
         name = V4, 
         qual = V5, 
         direction = V6)

```

## Beta Binomial Bottleneck

To calculate the transmission bottleneck, I'll use the Approximate Beta Binomial model as described [in this paper](https://doi.org/10.1128/JVI.00171-17). I'll [adapt some code](https://github.com/weissmanlab/BB_bottleneck/blob/master/Bottleneck_size_estimation_approx.r) from the Weissman lab that implements this model.

```{r Beta Binomial Function, echo=T}

# Implement the beta binomial model as function
approx.transmission.bottleneck = function(transmission.pair.df,
                                          freq.threshold,
                                          Nb.min,
                                          Nb.max,
                                          Nb.increment,
                                          confidence.interval){
  
  # This function gives Log Likelihood for every donor recipient SNP frequency pair
  log.beta.binom = function(nu.donor, nu.contact, NB.size, freq.threshold){ 
    
      nu.donor = if_else(nu.contact <= (1 - freq.threshold), nu.donor,  1 - nu.donor)
      nu.contact = if_else(nu.contact <= (1 - freq.threshold), nu.contact,  1 - nu.contact)
      
      ll.above = 0 
      ll.below = 0 
      for(k in 0:NB.size){
        ll.above = ll.above + dbeta(nu.contact, k, (NB.size - k) ) * dbinom(k, size = NB.size, prob = nu.donor)  
        ll.below = ll.below + pbeta(freq.threshold, k, (NB.size - k)) * dbinom(k, size = NB.size, prob = nu.donor)
        } 
    
    # We use LL_val_above above the calling threshold, and LL_val_below below the calling threshold
    ll.val = if_else(nu.contact >= freq.threshold , ll.above,  ll.below )
    # Convert likelihood to log likelihood
    ll.val = log(ll.val) 
    
    return(ll.val)
  }
  
  # This function sums over all SNP frequencies in the donor and recipient
  ll.approx = function(transmission.df, freq.threshold, NB.size){  
    ll.array = log.beta.binom(transmission.df$donor, transmission.df$contact, freq.threshold, NB.size)  
    sum.ll = sum(ll.array)
    return(sum.ll)
  }

  # Filter out variants below the minimum frequency threshold in donor
  transmission.pair.df = transmission.pair.df %>% 
    filter(donor >= freq.threshold,
           donor <= 1 - freq.threshold)
  
  # Make a data frame to hold the log likelihood 
  ll.df = tibble(bottleneck_size = seq(from = Nb.min, to = Nb.max, by = Nb.increment), log_likelihood = 0) 
  
  # Calculate the log likelihood for each bottleneck size
  for(i in 1:nrow(ll.df) ){
    ll.df$log_likelihood[i] = ll.approx(transmission.pair.df, ll.df$bottleneck_size[i], freq.threshold) 
  }
  
  # Bottleneck size at which max likelihood occurs and that bottleneck
  max.ll = max(ll.df$log_likelihood)
  bottleneck.size = ll.df %>% 
  filter(log_likelihood == max.ll) %>% 
  pull(bottleneck_size)
  
  # Calculate the confidence interval
  likelihood.ratio = qchisq(confidence.interval, df = 1) 
  ci.df = filter(ll.df, 2 * (max.ll - log_likelihood) <= likelihood.ratio) 
  lower.ci.bottleneck = min(ci.df$bottleneck_size) 
  upper.ci.bottleneck = max(ci.df$bottleneck_size) 
  
  # If the confidence interval table is empty
  if (length(ci.df$log_likelihood) == 0){
    lower.ci.bottleneck = min(bottleneck.size) 
    upper.ci.bottleneck = max(bottleneck.size)
  }
  # if the bottleneck is likely larger then the max set by user
  if (max(bottleneck.size) == Nb.max){
    upper.ci.bottleneck = Nb.max
    print("Peak bottleneck value for MLE is at Nb.max! Try raising Nb.max for better bottleneck estimate.")
  }
  # if the bottleneck is likely smaller then the min set by user
  if (min(bottleneck.size) == Nb.min){
    lower_CI_bottleneck = Nb.min
    if(Nb.min > 1){
      print("Peak bottleneck value for MLE is at Nb.min! Try lowering Nb.min for better bottleneck estimate.")}
  }
  
  return(c(lower.ci.bottleneck, bottleneck.size, upper.ci.bottleneck))

}

```

## Unfiltered Bottleneck

I'll use the merged variants from multiple replicates and variant callers to calculate the bottleneck. I won't add any additional filters that weren't used identify this set of variants. 

First, I'll get all of the pairwise comparisons between conditions in each cage (`Experiment`).

```{r Donor Contact Pairs}

# Get the donor contact pairs for each experiment
combinations.df = merged.df %>% 
  filter(Pair != "stock") %>% 
  select(Experiment, Animal, Pair) %>% 
  distinct() %>% 
  group_by(Experiment, Pair) %>%
  mutate(combination_id = row_number()) %>%
  pivot_wider(id_cols = c("Experiment", "combination_id"), 
              names_from = "Pair", values_from = "Animal") %>%
  select(-combination_id) %>%
  ungroup() %>%
  group_by(Experiment) %>%
  summarize(combinations = list(expand.grid(donor = donor, contact = contact))) %>%
  pull(combinations) %>% 
  bind_rows() %>% 
  filter(!(is.na(donor) | is.na(contact))) %>% 
  left_join(merged.df %>%
              select(Experiment, Animal) %>%
              distinct(),
            by = c("contact" = "Animal")) %>%
  # Remove the pairs for experiment 19 where the replicates are mismatched 
  mutate(donor_replicate = str_extract(donor, "\\d$"),
         contact_replicate = str_extract(contact, "\\d$")) %>% 
  filter(!(Experiment == 19 & (donor_replicate != contact_replicate))) %>% 
  select(!c(donor_replicate, contact_replicate)) 

```

Then, I'll determine the number of days post infection for the samples being compared. Ideally, the earliest time post contact will provide the most accurate bottleneck measurement. 

```{r Check Earliest Time}

# Add the earliest time points from each animal to the data frame
for (i in 1:nrow(combinations.df)) {
  # Get the donor and the contact 
  donor = combinations.df[i,]$donor
  contact = combinations.df[i,]$contact
  # Get the earliest day for each condition
  earliest.donor.dpc = merged.df %>% 
    filter(Animal == donor) %>% 
    pull(DPC) %>% 
    min()
  earliest.contact.dpc = merged.df %>% 
    filter(Animal == contact) %>% 
    pull(DPC) %>% 
    min()
  # Add these to the combinations
  combinations.df$donor_dpc[i] = earliest.donor.dpc
  # Add these to the combinations
  combinations.df$contact_dpc[i] = earliest.contact.dpc

}

head(combinations.df)
```

I'll iterate over each of these comparisons and calculate the bottleneck using the beta binomial method defined above. I'll also save the data frame comparing each animal to plot 'TV' plots showing the frequency of alleles in the donor and the contact. 

```{r Bottleneck without Filter, echo=TRUE}

bottleneck.df = data.frame()
tv.df = data.frame()
for (i in 1:nrow(combinations.df)) {
  
  # Donor information
  donor = combinations.df[i,]$donor
  donor.dpc = combinations.df[i,]$donor_dpc
  donor.df = merged.df %>% 
    filter(Animal == donor, 
           DPC == donor.dpc) %>% 
    mutate(donor = AF) %>% 
    select(SNP, donor)
    
  # Contact information
  contact = combinations.df[i,]$contact
  contact.dpc = combinations.df[i,]$contact_dpc
  contact.df = merged.df %>% 
    filter(Animal == contact, 
           DPC == contact.dpc) %>% 
    mutate(contact = AF) %>% 
    select(SNP, contact)
  
  # Combine into single data frame
  transmission.pair.df = full_join(donor.df, contact.df, by = "SNP") %>% 
    mutate(donor = if_else(is.na(donor), 0, donor),
           contact = if_else(is.na(contact), 0, contact)) 
  
  # Calculate the bottleneck
  bottleneck = approx.transmission.bottleneck(transmission.pair.df,
                                 freq.threshold = 0.02,
                                 Nb.min = 1,
                                 Nb.max = 500,
                                 Nb.increment = 1,
                                 confidence.interval = .95)
  
  # Make a new bottleneck row
  bottleneck.row = list(lower_ci = bottleneck[1], 
                        upper_ci = bottleneck[3],
                        bottleneck = bottleneck[2],
                        experiment = combinations.df[i,]$Experiment,
                        donor = donor,
                        contact = contact)

  # Append the row to the bottleneck data frame 
  bottleneck.df = rbind(bottleneck.df, bottleneck.row)
  
  # Append frequencies from joined pairs for the TV plots
  transmission.pair.df$Experiment  = combinations.df[i,]$Experiment
  transmission.pair.df$Pair  = paste(donor, contact, sep = "-")
  tv.df = rbind(tv.df, transmission.pair.df)
  
}
  
```

Let's see how the bottlenecks summarized for each condition. Below, I'm plotting the bottleneck size for each pairwise comparison as a point. I'm plotting the mean of those comparisons as a black circle. The error bars represent the **minimum lower bound of a 95% CI and the maximum upper bound of a 95% CI for the comparisons being summarized**. These error bars are certainly too conservative. One question is *what is an appropriate way to combine animals from the same cage?*

```{r Plot Raw Bottlenecks, fig.align='center', fig.width=8, fig.height=4}

# Condition order 
condition.order = c("no impactor",
                    "5 um impactor",
                    "2.5 um impactor",
                    "aerosol transmission",
                    "direct transmission")

# Get the conditions for each contact animal
conditions = merged.df %>% 
  select(Animal, Condition) %>% 
  distinct()

# Calculate the mean bottleneck for each condition
mean.bottleneck = bottleneck.df %>% 
  left_join(., conditions, by = c("contact" = "Animal")) %>% 
  mutate(Condition = fct_relevel(as_factor(Condition), condition.order)) %>% 
  mutate(Pair = paste(donor, contact, sep = "-")) %>% 
  group_by(Condition) %>% 
  summarize(bottleneck = mean(bottleneck),
            lower_ci = min(lower_ci),
            upper_ci = max(upper_ci))

# Add the conditions to the data frame and plot 
bottleneck.df %>% 
  left_join(., conditions, by = c("contact" = "Animal")) %>% 
  mutate(Condition = fct_relevel(as_factor(Condition), condition.order)) %>% 
  mutate(Pair = paste(donor, contact, sep = "-")) %>%  
  ggplot(aes(x = Condition, y = bottleneck, col = Condition)) + 
    geom_errorbar(data = mean.bottleneck, aes(ymin = lower_ci, ymax = upper_ci), width = 0.2, col = "black") +
    geom_point(data = mean.bottleneck, shape = 1, size = 3, col = "black") + 
    geom_jitter(width = 0.1) + 
    xlab("") + 
    ylab("Bottleneck Size") + 
    theme_bw()  +
    # theme(axis.text.x = element_text(angle = 35, hjust = 1))  + 
    theme(legend.position = "none")

ggsave(paste(figures.dir, "unfiltered_bottleneck.png", sep=""), width = 8, height = 4)

```

Generally, the trend isn't super clear other than direct transmission seems to have a looser bottleneck than aerosol transmission. Also, aerosol transmission seems to have a tighter bottleneck than when an impactor is used. However, it's important to make sure that these results aren't being skewed by artifacts.

As I showed in the previous notebook, there are variants shared between cages that weren't detected in the isolate. These could be an indication of false-positives that could skew the bottleneck calculation towards higher than actual values. In fact, given the literature, the bottleneck is higher than I would naively expect. Below, I'll plot 'TV' plots comparing the frequency of variants between the donors and contacts. This will show us if there are any unusual patterns.

```{r Raw TV Plots, fig.align='center', fig.width=8, fig.height=8}

tv.df %>% 
  separate(Pair, c("donor_animal", "contact_animal"), sep = "-") %>% 
  left_join(., conditions, by = c("contact_animal" = "Animal")) %>% 
  mutate(Experiment = paste(Experiment, " (", Condition, ")", sep = "")) %>% 
  ggplot(aes(x = donor, y = contact)) + 
    geom_point() + 
    facet_wrap(~Experiment) +
    theme_bw()

ggsave(paste(figures.dir, "unfiltered_tv_plot.png", sep=""), width = 8, height = 8)

```

Indeed, there are some variants that see to be present at similar low frequencies between donors and contacts. This somewhat defies our expectations given that we often see variants fixing in the contacts in experiments/cages, which requires a fairly tight bottleneck that wouldn't preserve the frequency of these minor variants between donors and contacts. 

Below, I'll try to figure out what these variants are and see if they're present outside of individual cages. I'll plot the animals on the x-axis, the allele frequency on the y-axis, I'll color an animal by whether it's a donor or contact, and I'll show the frequency of the variant in the isolate. 

```{r Shared Variants, fig.width=25, fig.height=20, fig.align="center"}

# Get the amino acid annotations for each variant from Pysam
amino_acid_annotations = variant.df %>% 
  filter(CALLER == 'pysam') %>% 
  select(POS, REF, ALT, POS_AA, REF_AA, ALT_AA, GENE) %>% 
  mutate(SNP = paste(REF, POS, ALT, sep = "")) %>% 
  select(!c(POS, REF, ALT)) %>% 
  distinct()

# Fixed in the isolate
fixed.in.isolate = merged.df %>%  
  filter(Animal == "stock",
         AF >= .98) %>% 
  pull(SNP)
  
# Variants between donor and contact
trasmitted.snps = tv.df %>% 
  filter(donor > 0 & contact > 0,
         !SNP %in% fixed.in.isolate) %>% 
  pull(SNP) %>% 
  unique()

# Get all of the variants in the isolate
isolate.variants = variant.df %>% 
  filter(CALLER == 'pysam') %>% 
  filter(Animal == "stock") %>% 
  select(POS, REF, ALT, POS_AA, REF_AA, ALT_AA, GENE, Animal, Pair, Experiment, Condition, DPC, AF) %>% 
  mutate(SNP = paste(REF, POS, ALT, sep = "")) %>% 
  mutate(AA_Change = paste(GENE, ":", " ", REF_AA, POS_AA, ALT_AA, sep="")) %>% 
  mutate(AA_Change = case_when(
    is.na(GENE) ~ "intergenic", 
    TRUE ~ AA_Change
  )) %>% 
  mutate(Mutation = paste(SNP, " (", AA_Change , ")")) %>% 
  filter(SNP %in% trasmitted.snps)  

# Expand the merged variants data frame with variant records for every animal (including presence and absence)
# experiment_ids = c("Animal", "Pair", "Experiment", "Condition", "DPC")
expanded.merged.df = merged.df %>% 
  select(POS, REF, ALT, SNP, Animal, Pair, Experiment, Condition, DPC, AF) %>% 
  # pivot_wider(id_cols = experiment_ids, names_from = SNP, values_from = AF, values_fill = 0) %>% 
  # pivot_longer(!experiment_ids, names_to = "SNP", values_to = "AF") %>% 
  left_join(., amino_acid_annotations, by = "SNP") %>% 
  filter(SNP %in% trasmitted.snps)  %>% 
  mutate(AA_Change = paste(GENE, ":", " ", REF_AA, POS_AA, ALT_AA, sep="")) %>% 
  mutate(AA_Change = case_when(
    is.na(GENE) ~ "intergenic", 
    TRUE ~ AA_Change
  )) %>% 
  mutate(Animal_Number = if_else(str_sub(Animal, -1, - 1)   == "1", "1", "2")) %>% 
  mutate(Mutation = paste(SNP, " (", AA_Change , ")")) 
  
# Condition order 
shortened.condition.order = c("none",
                    "5 um",
                    "2 um",
                    "aerosol",
                    "direct")

# Fix the fact that the same donor was used for aerosol and direct conditions
ivc.cage.variants = expanded.merged.df %>% 
  filter(Condition == "no impactor/IVC cage") 
ivc.cage.variants.aerosol = ivc.cage.variants %>% 
  mutate(Condition = "aerosol transmission")
ivc.cage.variants.direct = ivc.cage.variants %>% 
  mutate(Condition = "direct transmission")
expanded.merged.df = expanded.merged.df %>% 
  filter(Condition != "no impactor/IVC cage") %>% 
  bind_rows(ivc.cage.variants.direct, ivc.cage.variants.aerosol) %>% 
  mutate(Condition = case_when(
    Condition == "no impactor" ~ "none",
    Condition == "5 um impactor" ~ "5 um",
    Condition == "2.5 um impactor" ~ "2 um",
    Condition == "aerosol transmission" ~ "aerosol",
    Condition == "direct transmission" ~ "direct"
  )) %>% 
  mutate(Condition = fct_relevel(as_factor(Condition), shortened.condition.order)) 

# Plot the variants
expanded.merged.df %>% 
  filter(Animal != "stock") %>% 
  ggplot(aes(x = Condition, y = AF)) +
    geom_hline(data = isolate.variants, aes(yintercept = AF), col = "#bd00ba", size = 1, linetype = "dashed") +
    geom_jitter(aes(col = Pair, group = Pair, shape = Animal_Number), na.rm=TRUE, position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.9), size = 5, alpha = 0.6) +
    facet_wrap(~fct_reorder(Mutation, POS, min)) +
    # Annotate the separation between experiments
    geom_vline(xintercept = 1.5, linetype = 2, col = "grey") + 
    geom_vline(xintercept = 2.5, linetype = 2, col = "grey") + 
    geom_vline(xintercept = 3.5, linetype = 2, col = "grey") + 
    geom_vline(xintercept = 4.5, linetype = 2, col = "grey") + 

    xlab("Condition") +
    ylab("Allele Frequency") + 
    scale_color_manual(values = c("#bd0000", "#0013bd"), name = "") +
    theme_classic()  +
      theme(legend.position="bottom", legend.box = "horizontal") +
      theme(legend.box.background = element_rect(colour = "black")) +
      theme(text=element_text(size=24,  family="Helvetica")) +
      theme(plot.title = element_text(hjust = 0.5)) +
      theme(panel.background = element_rect(fill = NA, color = "black")) +
      theme(axis.text.x = element_text(size = 18)) + 
      theme(panel.spacing = unit(2, "lines")) + 
      theme(axis.ticks.length=unit(.25, "cm")) +
      guides(shape = FALSE)

ggsave(paste(figures.dir, "unfiltered_shared_variant_plot.png", sep=""), width = 25, height = 20)

```

## Filtered Bottleneck

Below, I'm going to try some more stringent filters to remove possible false-positive variants that might bias the bottleneck estimation. In the previous notebook, I noticed that there we some variants shared between cages that weren't present in the isolate. These could drastically impact the bottleneck size. 

```{r Filter the Merged Variants, echo=T}

# Try some more stringent filters
min.obsv = 25
min.bias = .9
min.freq = 0.02

# Get the SNPs that are in primer stretches 
snps.in.primers = merged.df %>% 
  select(POS, SNP) %>% 
  left_join(., select(primer.df, c(start, end)), by = character()) %>% 
  mutate(in_primer = between(POS, start, end, incbounds = TRUE)) %>% 
  filter(in_primer) %>% 
  pull(SNP) %>% 
  unique()
  
# Filter the merged data frame
filtered.merged.df = merged.df %>% 
  mutate(OBSV = ADR + ADF) %>% 
  mutate(BIAS = pmax(ADR, ADF) / OBSV) %>% 
  filter(
    OBSV >= min.obsv,
    BIAS <= min.bias,
    AF >= min.freq,
    !SNP %in% snps.in.primers
  )

```

I added a filter to remove variants with fewer than `r min.obsv` reads with variant alleles, less than `r min.bias` percent of one read direction supporting a variant, and less than `r min.freq` allele frequency. Additionally, although primers should be trimmed from the reads based on their direction, some primer sequences are still left in. I'll see if there are variants that are present in primer sequences and mask these. 

Now, I'll calculate the bottleneck for this new set of reads. 

```{r Calculate Filtered Bottleneck, echo=T}

filtered.bottleneck.df = data.frame()
filtered.tv.df = data.frame()
for (i in 1:nrow(combinations.df)) {
  
  # Donor information
  donor = combinations.df[i,]$donor
  donor.dpc = combinations.df[i,]$donor_dpc
  donor.df = filtered.merged.df %>% 
    filter(Animal == donor, 
           DPC == donor.dpc) %>% 
    mutate(donor = AF) %>% 
    select(SNP, donor)
    
  # Contact information
  contact = combinations.df[i,]$contact
  contact.dpc = combinations.df[i,]$contact_dpc
  contact.df = filtered.merged.df %>% 
    filter(Animal == contact, 
           DPC == contact.dpc) %>% 
    mutate(contact = AF) %>% 
    select(SNP, contact)
  
  # Combine into single data frame
  transmission.pair.df = full_join(donor.df, contact.df, by = "SNP") %>% 
    mutate(donor = if_else(is.na(donor), 0, donor),
           contact = if_else(is.na(contact), 0, contact)) 
  
  # Calculate the bottleneck
  bottleneck = approx.transmission.bottleneck(transmission.pair.df,
                                 freq.threshold = min.freq,
                                 Nb.min = 1,
                                 Nb.max = 500,
                                 Nb.increment = 1,
                                 confidence.interval = .95)
  
  # Make a new bottleneck row
  bottleneck.row = list(lower_ci = bottleneck[1], 
                        upper_ci = bottleneck[3],
                        bottleneck = bottleneck[2],
                        experiment = combinations.df[i,]$Experiment,
                        donor = donor,
                        contact = contact)

  # Append the row to the bottleneck data frame 
  filtered.bottleneck.df = rbind(filtered.bottleneck.df, bottleneck.row)
  
  # Append frequencies from joined pairs for the TV plots
  transmission.pair.df$Experiment  = combinations.df[i,]$Experiment
  transmission.pair.df$Pair  = paste(donor, contact, sep = "-")
  filtered.tv.df = rbind(filtered.tv.df, transmission.pair.df)

}

```

Now, I'll plot the bottleneck to see how these filters effect our expectations. 

```{r Plot Filtered Bottlenecks, fig.align='center', fig.width=8, fig.height=4}

# Calculate the mean bottleneck for each condition
mean.filtered.bottleneck = filtered.bottleneck.df %>% 
  left_join(., conditions, by = c("contact" = "Animal")) %>% 
  mutate(Condition = fct_relevel(as_factor(Condition), condition.order)) %>% 
  mutate(Pair = paste(donor, contact, sep = "-")) %>% 
  group_by(Condition) %>% 
  summarize(bottleneck = mean(bottleneck),
            lower_ci = min(lower_ci),
            upper_ci = max(upper_ci))

# Add the conditions to the data frame and plot 
filtered.bottleneck.df %>% 
  left_join(., conditions, by = c("contact" = "Animal")) %>% 
  mutate(Condition = fct_relevel(as_factor(Condition), condition.order)) %>% 
  mutate(Pair = paste(donor, contact, sep = "-")) %>%  
  ggplot(aes(x = Condition, y = bottleneck, col = Condition)) + 
    geom_errorbar(data = mean.filtered.bottleneck, aes(ymin = lower_ci, ymax = upper_ci), width = 0.2, col = "black") +
    geom_point(data = mean.filtered.bottleneck, shape = 1, size = 3, col = "black") + 
    geom_jitter(width = 0.1) + 
    xlab("") + 
    ylab("Bottleneck Size") + 
    theme_bw()  +
    # theme(axis.text.x = element_text(angle = 35, hjust = 1))  + 
    theme(legend.position = "none")

ggsave(paste(figures.dir, "filtered_bottleneck.png", sep=""), width = 8, height = 4)

```

It's probably not the case that the two new conditions are really comparable to the first three since the experimental design was different. I'll break these onto separate plots. 

```{r Alternative Plot Filtered Bottlenecks, fig.align='center', fig.width=8, fig.height=4}

# Add the conditions to the data frame and plot 
filtered.bottleneck.plot.df = filtered.bottleneck.df %>% 
  left_join(., conditions, by = c("contact" = "Animal")) %>% 
  mutate(Condition = fct_relevel(as_factor(Condition), condition.order)) %>% 
  mutate(Pair = paste(donor, contact, sep = "-")) 
  
filtered.bottleneck.plot.df %>% 
  filter(Condition %in% c("aerosol transmission", "direct transmission")) %>% 
  mutate(Pair = factor(Pair, levels = c("19D1-19AC1", "19D2-19AC1", "19D1-19AC2", "19D2-19AC2", "19D1-19DC1", "19D2-19DC1", "19D1-19DC2", "19D2-19DC2"))) %>%
  ggplot(aes(x = Pair, y = bottleneck, col = Condition)) + 
    geom_errorbar(aes(ymin = lower_ci, ymax = upper_ci), width = 0.2, col = "black") +
    geom_point() + 
    xlab("Donor-Contact Pair") + 
    ylab("Bottleneck Size") + 
    theme_bw()  +
    theme(axis.text.x = element_text(angle = 35, hjust = 1))  +
    theme(legend.position = "bottom")

ggsave(paste(figures.dir, "filtered__a_v_d_bottleneck.png", sep=""), width = 6, height = 4)

  
filtered.bottleneck.plot.df %>% 
  filter(!Condition %in% c("aerosol transmission", "direct transmission")) %>% 
  ggplot(aes(x = Pair, y = bottleneck, col = Condition)) + 
    geom_errorbar(aes(ymin = lower_ci, ymax = upper_ci), width = 0.2, col = "black") +
    geom_point() + 
    xlab("Donor-Contact Pair") + 
    ylab("Bottleneck Size") + 
    theme_bw()  +
    theme(axis.text.x = element_text(angle = 35, hjust = 1))  +
    theme(legend.position = "bottom")

ggsave(paste(figures.dir, "filtered__impactor_bottleneck.png", sep=""), width = 8, height = 4)

```

Let's see what the 'TV' plots look like. These will give us some sense of whether we got rid of variants that could be false-positives. 

```{r Filtered TV Plots, fig.align='center', fig.width=8, fig.height=8}

filtered.tv.df %>% 
  separate(Pair, c("donor_animal", "contact_animal"), sep = "-") %>% 
  left_join(., conditions, by = c("contact_animal" = "Animal")) %>% 
  mutate(Experiment = paste(Experiment, " (", Condition, ")", sep = "")) %>% 
  ggplot(aes(x = donor, y = contact)) + 
    geom_point() + 
    facet_wrap(~Experiment) +
    theme_bw()

ggsave(paste(figures.dir, "filtered_tv_plot.png", sep=""), width = 8, height = 8)

```

Let's take a closer look at the shared variants that are left over. 

```{r Filtered Shared Variants, fig.width=25, fig.height=20, fig.align="center"}

# Get the amino acid annotations for each variant from Pysam
amino_acid_annotations = variant.df %>% 
  filter(CALLER == 'pysam') %>% 
  select(POS, REF, ALT, POS_AA, REF_AA, ALT_AA, GENE) %>% 
  mutate(SNP = paste(REF, POS, ALT, sep = "")) %>% 
  select(!c(POS, REF, ALT)) %>% 
  distinct()

# Fixed in the isolate
fixed.in.isolate = merged.df %>%  
  filter(Animal == "stock",
         AF >= .98) %>% 
  pull(SNP)
  
# Variants between donor and contact
trasmitted.snps = filtered.tv.df %>% 
  filter(donor > 0 & contact > 0,
         !SNP %in% fixed.in.isolate) %>% 
  pull(SNP) %>% 
  unique()

# Get all of the variants in the isolate
filtered.isolate.variants = variant.df %>% 
  filter(CALLER == 'pysam') %>% 
  filter(Animal == "stock") %>% 
  select(POS, REF, ALT, POS_AA, REF_AA, ALT_AA, GENE, Animal, Pair, Experiment, Condition, DPC, AF) %>% 
  mutate(SNP = paste(REF, POS, ALT, sep = "")) %>% 
  mutate(AA_Change = paste(GENE, ":", " ", REF_AA, POS_AA, ALT_AA, sep="")) %>% 
  mutate(AA_Change = case_when(
    is.na(GENE) ~ "intergenic", 
    TRUE ~ AA_Change
  )) %>% 
  mutate(Mutation = paste(SNP, " (", AA_Change , ")")) %>% 
  filter(SNP %in% trasmitted.snps)  

# Expand the merged variants data frame with variant records for every animal (including presence and absence)
# experiment_ids = c("Animal", "Pair", "Experiment", "Condition", "DPC")
expanded.merged.df = filtered.merged.df %>% 
  select(POS, REF, ALT, SNP, Animal, Pair, Experiment, Condition, DPC, AF) %>% 
  # pivot_wider(id_cols = experiment_ids, names_from = SNP, values_from = AF, values_fill = 0) %>% 
  # pivot_longer(!experiment_ids, names_to = "SNP", values_to = "AF") %>% 
  left_join(., amino_acid_annotations, by = "SNP") %>% 
  filter(SNP %in% trasmitted.snps)  %>% 
  mutate(AA_Change = paste(GENE, ":", " ", REF_AA, POS_AA, ALT_AA, sep="")) %>% 
  mutate(AA_Change = case_when(
    is.na(GENE) ~ "intergenic", 
    TRUE ~ AA_Change
  )) %>% 
  mutate(Animal_Number = if_else(str_sub(Animal, -1, - 1)   == "1", "1", "2")) %>% 
  mutate(Mutation = paste(SNP, " (", AA_Change , ")")) 
  
# Condition order 
shortened.condition.order = c("none",
                    "5 um",
                    "2 um",
                    "aerosol",
                    "direct")

# Fix the fact that the same donor was used for aerosol and direct conditions
ivc.cage.variants = expanded.merged.df %>% 
  filter(Condition == "no impactor/IVC cage") 
ivc.cage.variants.aerosol = ivc.cage.variants %>% 
  mutate(Condition = "aerosol transmission")
ivc.cage.variants.direct = ivc.cage.variants %>% 
  mutate(Condition = "direct transmission")
expanded.merged.df = expanded.merged.df %>% 
  filter(Condition != "no impactor/IVC cage") %>% 
  bind_rows(ivc.cage.variants.direct, ivc.cage.variants.aerosol) %>% 
  mutate(Condition = case_when(
    Condition == "no impactor" ~ "none",
    Condition == "5 um impactor" ~ "5 um",
    Condition == "2.5 um impactor" ~ "2 um",
    Condition == "aerosol transmission" ~ "aerosol",
    Condition == "direct transmission" ~ "direct"
  )) %>% 
  mutate(Condition = fct_relevel(as_factor(Condition), shortened.condition.order)) 

# Plot the variants
expanded.merged.df %>% 
  filter(Animal != "stock") %>% 
  ggplot(aes(x = Condition, y = AF)) +
    geom_hline(data = filtered.isolate.variants, aes(yintercept = AF), col = "#bd00ba", size = 1, linetype = "dashed") +
    geom_jitter(aes(col = Pair, group = Pair, shape = Animal_Number), na.rm=TRUE, position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.9), size = 5, alpha = 0.6) +
    facet_wrap(~fct_reorder(Mutation, POS, min)) +
    # Annotate the separation between experiments
    geom_vline(xintercept = 1.5, linetype = 2, col = "grey") + 
    geom_vline(xintercept = 2.5, linetype = 2, col = "grey") + 
    geom_vline(xintercept = 3.5, linetype = 2, col = "grey") + 
    geom_vline(xintercept = 4.5, linetype = 2, col = "grey") + 
    xlab("Condition") +
    ylab("Allele Frequency") + 
    scale_color_manual(values = c("#bd0000", "#0013bd"), name = "") +
    theme_classic()  +
      theme(legend.position="bottom", legend.box = "horizontal") +
      theme(legend.box.background = element_rect(colour = "black")) +
      theme(text=element_text(size=24,  family="Helvetica")) +
      theme(plot.title = element_text(hjust = 0.5)) +
      theme(panel.background = element_rect(fill = NA, color = "black")) +
      theme(axis.text.x = element_text(size = 18)) + 
      theme(panel.spacing = unit(2, "lines")) + 
      theme(axis.ticks.length=unit(.25, "cm")) +
      guides(shape = FALSE)

ggsave(paste(figures.dir, "filtered_shared_variant_plot.png", sep=""), width = 25, height = 20)

```

## Masking Possible Artifacts

There are still some variants that defy our expectations even after we applied the more stringent filters described above. In particular, these are `A15489T`, `C15494G`, `A22422G`, and `T24091C`. It's not clear why these variants are exhibiting the behavior that they are. I will investigate this in the future, but first, let's see what happens to the bottleneck calculation when we mask these variants. 

```{r Calculate Masked Bottleneck, echo=TRUE}

masked.snps = c('A15489T', 'C15494G', 'A22422G', 'T24091C')

masked.merged.df = filtered.merged.df %>% 
  filter(!SNP %in% masked.snps)

masked.bottleneck.df = data.frame()
masked.tv.df = data.frame()
for (i in 1:nrow(combinations.df)) {
  
  # Donor information
  donor = combinations.df[i,]$donor
  donor.dpc = combinations.df[i,]$donor_dpc
  donor.df = masked.merged.df %>% 
    filter(Animal == donor, 
           DPC == donor.dpc) %>% 
    mutate(donor = AF) %>% 
    select(SNP, donor)
    
  # Contact information
  contact = combinations.df[i,]$contact
  contact.dpc = combinations.df[i,]$contact_dpc
  contact.df = masked.merged.df %>% 
    filter(Animal == contact, 
           DPC == contact.dpc) %>% 
    mutate(contact = AF) %>% 
    select(SNP, contact)
  
  # Combine into single data frame
  transmission.pair.df = full_join(donor.df, contact.df, by = "SNP") %>% 
    mutate(donor = if_else(is.na(donor), 0, donor),
           contact = if_else(is.na(contact), 0, contact)) 
  
  # Calculate the bottleneck
  bottleneck = approx.transmission.bottleneck(transmission.pair.df,
                                 freq.threshold = min.freq,
                                 Nb.min = 1,
                                 Nb.max = 500,
                                 Nb.increment = 1,
                                 confidence.interval = .95)
  
  # Make a new bottleneck row
  bottleneck.row = list(lower_ci = bottleneck[1], 
                        upper_ci = bottleneck[3],
                        bottleneck = bottleneck[2],
                        experiment = combinations.df[i,]$Experiment,
                        donor = donor,
                        contact = contact)

  # Append the row to the bottleneck data frame 
  masked.bottleneck.df = rbind(masked.bottleneck.df, bottleneck.row)
  
  # Append frequencies from joined pairs for the TV plots
  transmission.pair.df$Experiment  = combinations.df[i,]$Experiment
  transmission.pair.df$Pair  = paste(donor, contact, sep = "-")
  masked.tv.df = rbind(masked.tv.df, transmission.pair.df)

}

```


```{r Plot Masked Bottlenecks, fig.align='center', fig.width=8, fig.height=4}

# Add the conditions to the data frame and plot 
masked.bottleneck.plot.df = masked.bottleneck.df %>% 
  left_join(., conditions, by = c("contact" = "Animal")) %>% 
  mutate(Condition = fct_relevel(as_factor(Condition), condition.order)) %>% 
  mutate(Pair = paste(donor, contact, sep = "-")) 
  
masked.bottleneck.plot.df %>% 
  filter(Condition %in% c("aerosol transmission", "direct transmission")) %>% 
  mutate(Pair = factor(Pair, levels = c("19D1-19AC1", "19D2-19AC2", "19D1-19DC1", "19D2-19DC2"))) %>%
  ggplot(aes(x = Pair, y = bottleneck, col = Condition)) + 
    geom_errorbar(aes(ymin = lower_ci, ymax = upper_ci), width = 0.2, col = "black") +
    geom_point() + 
    xlab("Donor-Contact Pair") + 
    ylab("Bottleneck Size") + 
    theme_bw()  +
    theme(axis.text.x = element_text(angle = 35, hjust = 1))  +
    theme(legend.position = "bottom")

ggsave(paste(figures.dir, "masked_a_v_d_bottleneck.png", sep=""), width = 6, height = 4)

  
masked.bottleneck.plot.df %>% 
  filter(!Condition %in% c("aerosol transmission", "direct transmission")) %>% 
  ggplot(aes(x = Pair, y = bottleneck, col = Condition)) + 
    geom_errorbar(aes(ymin = lower_ci, ymax = upper_ci), width = 0.2, col = "black") +
    geom_point() + 
    xlab("Donor-Contact Pair") + 
    ylab("Bottleneck Size") + 
    theme_bw()  +
    theme(axis.text.x = element_text(angle = 35, hjust = 1))  +
    theme(legend.position = "bottom")

ggsave(paste(figures.dir, "masked_impactor_bottleneck.png", sep=""), width = 8, height = 4)

```

## Improved Filtering

It's clear that there are some variants shared at low frequency between animals in multiple cages. What's interesting is that all of these variants are present in only the first rounds of sequencing. 

```{r Candidate False Positive Variants, echo = T}

candidate.false.positives = c("A15489T", "C15494G", "A22422G", "T24091C")

merged.df %>% 
  filter(SNP %in% candidate.false.positives) %>% 
  group_by(Sequencing_Round) %>% 
  count() %>% 
  kable(., caption = "Sequencing Round")

```

This makes sense if these are some kind of sequencing related artifact or contamination. Experimentally, it might be possible to remove these by sequencing the isolate in duplicate. For now, let's see what happens if we filter out variants that are only in a single sequencing round. 

```{r Variants Per Sequencing Round, echo = T}

snps.per.round = merged.df %>% 
  select(SNP, Sequencing_Round) %>% 
  distinct() %>% 
  group_by(SNP) %>% 
  count() %>% 
  rename(SeqRoundObsv = n) 

snps.in.both.sequencing.rounds = snps.per.round %>% 
  filter(SeqRoundObsv > 1) %>% 
  pull(SNP)

snps.per.round %>% 
  group_by(SeqRoundObsv) %>% 
  count() %>% 
  kable(., caption = "SNPs per Sequencing Round")

```

Most SNPs were found in a single sequencing run. How does this improve if I use the filters that I've applied before. 

```{r Filtered Variants Per Sequencing Round, echo = T}

filtered.merged.df %>% 
  select(SNP, Sequencing_Round) %>% 
  distinct() %>% 
  group_by(SNP) %>% 
  count() %>% 
  rename(SeqRoundObsv = n)%>% 
  group_by(SeqRoundObsv) %>% 
  count() %>% 
  kable(., caption = "Filtered SNPs per Sequencing Round")

```

Let's see how this filter changes the bottleneck estimation. 

```{r Calculate Multi Round Bottleneck, echo=T}

multi.round.merged.df = filtered.merged.df %>% 
  filter(SNP %in% snps.in.both.sequencing.rounds)

multi.round.bottleneck.df = data.frame()
multi.round.tv.df = data.frame()
for (i in 1:nrow(combinations.df)) {
  
  # Donor information
  donor = combinations.df[i,]$donor
  donor.dpc = combinations.df[i,]$donor_dpc
  donor.df = multi.round.merged.df %>% 
    filter(Animal == donor, 
           DPC == donor.dpc) %>% 
    mutate(donor = AF) %>% 
    select(SNP, donor)
    
  # Contact information
  contact = combinations.df[i,]$contact
  contact.dpc = combinations.df[i,]$contact_dpc
  contact.df = multi.round.merged.df %>% 
    filter(Animal == contact, 
           DPC == contact.dpc) %>% 
    mutate(contact = AF) %>% 
    select(SNP, contact)
  
  # Combine into single data frame
  transmission.pair.df = full_join(donor.df, contact.df, by = "SNP") %>% 
    mutate(donor = if_else(is.na(donor), 0, donor),
           contact = if_else(is.na(contact), 0, contact)) 
  
  # Calculate the bottleneck
  bottleneck = approx.transmission.bottleneck(transmission.pair.df,
                                 freq.threshold = min.freq,
                                 Nb.min = 1,
                                 Nb.max = 500,
                                 Nb.increment = 1,
                                 confidence.interval = .95)
  
  # Make a new bottleneck row
  bottleneck.row = list(lower_ci = bottleneck[1], 
                        upper_ci = bottleneck[3],
                        bottleneck = bottleneck[2],
                        experiment = combinations.df[i,]$Experiment,
                        donor = donor,
                        contact = contact)

  # Append the row to the bottleneck data frame 
  multi.round.bottleneck.df = rbind(multi.round.bottleneck.df, bottleneck.row)
  
  # Append frequencies from joined pairs for the TV plots
  transmission.pair.df$Experiment  = combinations.df[i,]$Experiment
  transmission.pair.df$Pair  = paste(donor, contact, sep = "-")
  multi.round.tv.df = rbind(multi.round.tv.df, transmission.pair.df)

}

# Add the conditions to the data frame and plot 
multi.round.bottleneck.plot.df = multi.round.bottleneck.df %>% 
  left_join(., conditions, by = c("contact" = "Animal")) %>% 
  mutate(Condition = fct_relevel(as_factor(Condition), condition.order)) %>% 
  mutate(Pair = paste(donor, contact, sep = "-")) 
  
multi.round.bottleneck.plot.df %>% 
  filter(Condition %in% c("aerosol transmission", "direct transmission")) %>% 
  mutate(Pair = factor(Pair, levels = c("19D1-19AC1", "19D2-19AC2", "19D1-19DC1", "19D2-19DC2"))) %>%
  ggplot(aes(x = Pair, y = bottleneck, col = Condition)) + 
    geom_errorbar(aes(ymin = lower_ci, ymax = upper_ci), width = 0.2, col = "black") +
    geom_point() + 
    xlab("Donor-Contact Pair") + 
    ylab("Bottleneck Size") + 
    theme_bw()  +
    theme(axis.text.x = element_text(angle = 35, hjust = 1))  +
    theme(legend.position = "bottom")

ggsave(paste(figures.dir, "multi_round_only_a_v_d_bottleneck.png", sep=""), width = 6, height = 4)

multi.round.bottleneck.plot.df %>% 
  filter(!Condition %in% c("aerosol transmission", "direct transmission")) %>% 
  ggplot(aes(x = Pair, y = bottleneck, col = Condition)) + 
    geom_errorbar(aes(ymin = lower_ci, ymax = upper_ci), width = 0.2, col = "black") +
    geom_point() + 
    xlab("Donor-Contact Pair") + 
    ylab("Bottleneck Size") + 
    theme_bw()  +
    theme(axis.text.x = element_text(angle = 35, hjust = 1))  +
    theme(legend.position = "bottom")

ggsave(paste(figures.dir, "multi_round_only_impactor_bottleneck.png", sep=""), width = 8, height = 4)


```

Unsurprisingly, the bottleneck looks the same as the 'masked' bottleneck. That's because all the SNPs that don't look like false-positives are found in only the first sequencing round. Let's show this below.

```{r Multi Round Shared Variants, fig.width=25, fig.height=15, fig.align="center"}

# Get the amino acid annotations for each variant from Pysam
amino_acid_annotations = variant.df %>% 
  filter(CALLER == 'pysam') %>% 
  select(POS, REF, ALT, POS_AA, REF_AA, ALT_AA, GENE) %>% 
  mutate(SNP = paste(REF, POS, ALT, sep = "")) %>% 
  select(!c(POS, REF, ALT)) %>% 
  distinct()

# Fixed in the isolate
fixed.in.isolate = merged.df %>%  
  filter(Animal == "stock",
         AF >= .98) %>% 
  pull(SNP)
  
# Variants between donor and contact
trasmitted.snps = multi.round.tv.df %>% 
  filter(donor > 0 & contact > 0,
         !SNP %in% fixed.in.isolate) %>% 
  pull(SNP) %>% 
  unique()

# Get all of the variants in the isolate
filtered.isolate.variants = variant.df %>% 
  filter(CALLER == 'pysam') %>% 
  filter(Animal == "stock") %>% 
  select(POS, REF, ALT, POS_AA, REF_AA, ALT_AA, GENE, Animal, Pair, Experiment, Condition, DPC, AF) %>% 
  mutate(SNP = paste(REF, POS, ALT, sep = "")) %>% 
  mutate(AA_Change = paste(GENE, ":", " ", REF_AA, POS_AA, ALT_AA, sep="")) %>% 
  mutate(AA_Change = case_when(
    is.na(GENE) ~ "intergenic", 
    TRUE ~ AA_Change
  )) %>% 
  mutate(Mutation = paste(SNP, " (", AA_Change , ")")) %>% 
  filter(SNP %in% trasmitted.snps)  

# Expand the merged variants data frame with variant records for every animal (including presence and absence)
# experiment_ids = c("Animal", "Pair", "Experiment", "Condition", "DPC")
expanded.merged.df = multi.round.merged.df %>% 
  select(POS, REF, ALT, SNP, Animal, Pair, Experiment, Condition, DPC, AF) %>% 
  # pivot_wider(id_cols = experiment_ids, names_from = SNP, values_from = AF, values_fill = 0) %>% 
  # pivot_longer(!experiment_ids, names_to = "SNP", values_to = "AF") %>% 
  left_join(., amino_acid_annotations, by = "SNP") %>% 
  filter(SNP %in% trasmitted.snps)  %>% 
  mutate(AA_Change = paste(GENE, ":", " ", REF_AA, POS_AA, ALT_AA, sep="")) %>% 
  mutate(AA_Change = case_when(
    is.na(GENE) ~ "intergenic", 
    TRUE ~ AA_Change
  )) %>% 
  mutate(Animal_Number = if_else(str_sub(Animal, -1, - 1)   == "1", "1", "2")) %>% 
  mutate(Mutation = paste(SNP, " (", AA_Change , ")")) 
  
# Condition order 
shortened.condition.order = c("none",
                    "5 um",
                    "2 um",
                    "aerosol",
                    "direct")

# Fix the fact that the same donor was used for aerosol and direct conditions
ivc.cage.variants = expanded.merged.df %>% 
  filter(Condition == "no impactor/IVC cage") 
ivc.cage.variants.aerosol = ivc.cage.variants %>% 
  mutate(Condition = "aerosol transmission")
ivc.cage.variants.direct = ivc.cage.variants %>% 
  mutate(Condition = "direct transmission")
expanded.merged.df = expanded.merged.df %>% 
  filter(Condition != "no impactor/IVC cage") %>% 
  bind_rows(ivc.cage.variants.direct, ivc.cage.variants.aerosol) %>% 
  mutate(Condition = case_when(
    Condition == "no impactor" ~ "none",
    Condition == "5 um impactor" ~ "5 um",
    Condition == "2.5 um impactor" ~ "2 um",
    Condition == "aerosol transmission" ~ "aerosol",
    Condition == "direct transmission" ~ "direct"
  )) %>% 
  mutate(Condition = fct_relevel(as_factor(Condition), shortened.condition.order)) 

# Plot the variants
expanded.merged.df %>% 
  filter(Animal != "stock") %>% 
  ggplot(aes(x = Condition, y = AF)) +
    geom_hline(data = filtered.isolate.variants, aes(yintercept = AF), col = "#bd00ba", size = 1, linetype = "dashed") +
    geom_jitter(aes(col = Pair, group = Pair, shape = Animal_Number), na.rm=TRUE, position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.9), size = 5, alpha = 0.6) +
    facet_wrap(~fct_reorder(Mutation, POS, min)) +
    # Annotate the separation between experiments
    geom_vline(xintercept = 1.5, linetype = 2, col = "grey") + 
    geom_vline(xintercept = 2.5, linetype = 2, col = "grey") + 
    geom_vline(xintercept = 3.5, linetype = 2, col = "grey") + 
    geom_vline(xintercept = 4.5, linetype = 2, col = "grey") + 
    xlab("Condition") +
    ylab("Allele Frequency") + 
    scale_color_manual(values = c("#bd0000", "#0013bd"), name = "") +
    theme_classic()  +
      theme(legend.position="bottom", legend.box = "horizontal") +
      theme(legend.box.background = element_rect(colour = "black")) +
      theme(text=element_text(size=24,  family="Helvetica")) +
      theme(plot.title = element_text(hjust = 0.5)) +
      theme(panel.background = element_rect(fill = NA, color = "black")) +
      theme(axis.text.x = element_text(size = 18)) + 
      theme(panel.spacing = unit(2, "lines")) + 
      theme(axis.ticks.length=unit(.25, "cm")) +
      guides(shape = FALSE)

ggsave(paste(figures.dir, "multi_round_only_shared_variant_plot.png", sep=""), width = 25, height = 20)

```

Now, I'll plot the bottleneck summarized into a single plot. 

```{r Plot Summarized Multi Round Bottlenecks, fig.align='center', fig.width=8, fig.height=4}

# Calculate the mean bottleneck for each condition
mean.filtered.bottleneck = multi.round.bottleneck.df %>% 
  left_join(., conditions, by = c("contact" = "Animal")) %>% 
  mutate(Condition = fct_relevel(as_factor(Condition), condition.order)) %>% 
  mutate(Pair = paste(donor, contact, sep = "-")) %>% 
  group_by(Condition) %>% 
  summarize(bottleneck = mean(bottleneck),
            lower_ci = min(lower_ci),
            upper_ci = max(upper_ci))

# Add the conditions to the data frame and plot 
multi.round.bottleneck.df %>% 
  left_join(., conditions, by = c("contact" = "Animal")) %>% 
  mutate(Condition = fct_relevel(as_factor(Condition), condition.order)) %>% 
  mutate(Pair = paste(donor, contact, sep = "-")) %>%  
  ggplot(aes(x = Condition, y = bottleneck, col = Condition)) + 
    geom_errorbar(data = mean.filtered.bottleneck, aes(ymin = lower_ci, ymax = upper_ci), width = 0.2, col = "black") +
    geom_point(data = mean.filtered.bottleneck, shape = 1, size = 3, col = "black") + 
    geom_jitter(width = 0.1) + 
    xlab("") + 
    ylab("Bottleneck Size") + 
    theme_bw(18)  +
    # theme(axis.text.x = element_text(angle = 35, hjust = 1))  + 
    theme(legend.position = "none")

ggsave(paste(figures.dir, "multi_round_only_summarized_bottleneck.png", sep=""), width = 8, height = 4)

```

What are the actual bottleneck sizes for each condition? 

```{r Bottleneck Sizes, echo = F}

mean.filtered.bottleneck %>% 
  kable(., caption = "Average Botlteneck Sizes")

```

## Bottleneck Variability

It's clear that with stringent filters, the estimate for the bottleneck is pretty variable. It's hard to say whether this is due to some natural feature of the system, the fact that not all donor-contact pairs are true donor-contact pairs, or false-positive variants. 

One way to explore some of this inherent variability is to see how variable the bottleneck is between the stock and the contacts. We know that the stock was used to inoculate the contacts. Therefore, the bottleneck should be significantly higher than the transmission pairs above. 

```{r Plot Filtered Stock Bottleneck, warning=FALSE}

# Make a data frame of isolate/contact pairs 
stock.comparison.df = multi.round.merged.df %>% 
  filter(Pair == "donor") %>% 
  select(Experiment, contact = "Animal")  %>% 
  distinct() %>% 
  mutate(donor = "stock")

# Add the earliest time points from each animal to the data frame
for (i in 1:nrow(stock.comparison.df)) {
  # Get the donor and the contact 
  donor = stock.comparison.df[i,]$donor
  contact = stock.comparison.df[i,]$contact
  # Get the earliest day for each condition
  earliest.donor.dpc = multi.round.merged.df %>% 
    filter(Animal == donor) %>% 
    pull(DPC) %>% 
    min()
  earliest.contact.dpc = multi.round.merged.df %>% 
    filter(Animal == contact) %>% 
    pull(DPC) %>% 
    min()
  # Add these to the combinations
  stock.comparison.df$donor_dpc[i] = earliest.donor.dpc
  # Add these to the combinations
  stock.comparison.df$contact_dpc[i] = earliest.contact.dpc
}

# Calculate the bottleneck between the stock and each time point
stock.bottleneck.df = data.frame()
stock.tv.df = data.frame()
for (i in 1:nrow(stock.comparison.df)) {
  
  # Donor information
  donor = stock.comparison.df[i,]$donor
  donor.dpc = stock.comparison.df[i,]$donor_dpc
  donor.df = multi.round.merged.df %>% 
    filter(Animal == donor, 
           DPC == donor.dpc) %>% 
    mutate(donor = AF) %>% 
    select(SNP, donor)
    
  # Contact information
  contact = stock.comparison.df[i,]$contact
  contact.dpc = stock.comparison.df[i,]$contact_dpc
  contact.df = multi.round.merged.df %>% 
    filter(Animal == contact, 
           DPC == contact.dpc) %>% 
    mutate(contact = AF) %>% 
    select(SNP, contact)
  
  # Combine into single data frame
  transmission.pair.df = full_join(donor.df, contact.df, by = "SNP") %>% 
    mutate(donor = if_else(is.na(donor), 0, donor),
           contact = if_else(is.na(contact), 0, contact)) 
  
  # Calculate the bottleneck
  bottleneck = approx.transmission.bottleneck(transmission.pair.df,
                                 freq.threshold = 0.02,
                                 Nb.min = 1,
                                 Nb.max = 500,
                                 Nb.increment = 1,
                                 confidence.interval = .95)
  
  # Make a new bottleneck row
  bottleneck.row = list(lower_ci = bottleneck[1], 
                        upper_ci = bottleneck[3], 
                        bottleneck = bottleneck[2],
                        experiment = stock.comparison.df[i,]$Experiment,
                        donor = donor,
                        contact = contact)

  # Append the row to the bottleneck data frame 
  stock.bottleneck.df = rbind(stock.bottleneck.df, bottleneck.row)
  
  # Append frequencies from joined pairs for the TV plots
  transmission.pair.df$Experiment  = stock.comparison.df[i,]$Experiment
  transmission.pair.df$Pair = paste(donor, contact, sep = "-")
  stock.tv.df = rbind(stock.tv.df, transmission.pair.df)

}

# Add the conditions to the data frame and plot 
stock.bottleneck.df %>% 
  left_join(., conditions, by = c("contact" = "Animal")) %>% 
  ggplot(aes(x = contact, y = bottleneck, col = Condition)) + 
    geom_errorbar(aes(ymin = lower_ci, ymax = upper_ci), width = 0.2, col = "black") +
    geom_point(size = 3) + 
    xlab("Contact Animal") + 
    ylab("Bottleneck Size") + 
    theme_bw()  +
    theme(legend.position = "bottom")

ggsave(paste(figures.dir, "filtered_stock_bottleneck.png", sep=""), width = 8, height = 4)


```

## Conclusion

Generally, the conclusion of this notebook so far is that the bottleneck is narrow, but it still influenced by possible false positive variants. It's not totally clear what the impact of particle size is on the bottleneck. Generally it seems like the bottleneck isn't strongly influenced, but might be restricted by the particle size.


